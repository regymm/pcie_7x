## pcie_7x Usage Guide

#### Boards

pcie_7x supports PCIe Gen1/Gen2 x1, on AMD/Xilinx Artix 7 FPGAs with GTP transceivers. 

Depends on the chip speed grade, Gen2 may not be supported, like the xc7a100tfgg484-1 has GTP only up to 3.75Gbps, while Gen2 requires 5Gbps. I found this fact less documented. 

#### Constraints

Since GT locations are mostly fixed, it might be even easier than constraining an ordinary design -- just the REFCLK(P/N), RX(P/N), TX(P/N), and recommended RESET#. 

Boards with transceivers usually have differential oscillators, but GT REFCLK is usually selected to be the 100 MHz coming from PCIe Root Complex (PCIe gold finger). 

#### Build bitstream

It's just adding all the Verilog files, constraints, and set the top! 

To use the Vivado flow, 

#### OpenXC7

pcie_7x can be build with the [open-source toolchain for Xilinx 7-Series FPGAs](https://github.com/openXC7). Makefiles (generated by [caas-wizard](https://github.com/FPGAOL-CE/caas-wizard)) are also included. 

#### Test: BAR memory access

A quick test can utilize the PCIe remove and rescan. E.g. when host computer starts, bitstream in flash is loaded: 

```
$ lspci -s 26:00.0     
26:00.0 Memory controller: Meta Platforms, Inc. Device 0400
```

Remove it:

```
$ echo 1 > /sys/bus/pci/devices/0000:26:00.0/remove
```

Program new bitstream, and rescan:

```
echo 1 > /sys/bus/pci/rescan
```

The new device may show up. If it doesn't, do a reboot to properly reset and re-enumerate (the safe way, especially when changing BAR size, etc). Bitstream will remain loaded during reboot. 

```
$ lspci -s 26:00.0       
26:00.0 Memory controller: Xilinx Corporation Device 9999
```

Then, if a chunk of memory is connected to the endpoint, like the `pcie_7x_aximm` example, it can be accessed from PC. 

[pcimem](https://github.com/billfarrow/pcimem) can be used to access BAR memories easily from the command line. 

#### Debug

LEDs on board can be used to show status (there's Vivado ILA, which is not available on openXC7). When things doesn't work, troubleshooting can be done in this order: 

- [ ] Check if design works in **simulation**. 
- [ ] Check if design works with **code boot without JTAG connected** / host PC **reboot**. 
- [ ] Check if design works in PCIe **Gen1** mode. 
- [ ] Check if **reset** is asserted then de-asserted on real hardware. 
- [ ] Check if **clock** output is valid on real hardware. 
- [ ] Check if **GT** initialization `[4:0]gt_reset_fsm` proceeds correctly. 
- [ ] Check if **training** `[5:0]pl_ltssm_state` proceeds correctly according to UG477. 
- [ ] Check if **link up** `user_link_up` is asserted. Check if `user_link_up` is up **momentarily**, if host PC keeps resetting. 
- [ ] Check if PCIE_2_1 Block **Ram**/Distributed Ram has correct size and is working. 

As long as the PCIe device can be shown in `lspci`, debugging becomes slightly easier. 