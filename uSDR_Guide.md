## PCIe Gen2 on Wavelet Lab uSDR

#### Hardware

[A tiny, single-sided M.2 SDR board that you can operate easily using your web browser](https://www.crowdsupply.com/wavelet-lab/usdr)

[Related uSDR setup article: uSDR with PCIe interface on RPi5](https://gist.github.com/regymm/8f9188ac8f2be554c3ba825dee4813e2)

It has a Artix 7 35T FPGA, with 2-lane GTP, capable of PCIe Gen2 (5Gbps). 

As in `pcie_7x_top_aximm_user.v`, it reuses the ordinary top module, just removes the reset (using an internal counter to reset, instead), and enables PCIe Gen2. This configures the PCIE_2_1 hard block to allow Gen2, and configures the user clock to be 125 MHz. 

Link training at startup will always begin from 2.5G Gen1, if host and device found each other supports Gen2, they will change transceiver speed to 5G, and negotiate again. 

The `xilinx_pci_mmcm` accepts a `pclk_sel_i` input from PCIE_2_1, to control the pclk/rxusrclk/oobclk frequency (125 MHz for Gen1, 250 MHz for Gen2). GTP TX alignment will also be performed again when a rate change is detected. 

#### Reset

The board has a interesting feature of power-cycling the FPGA fabric with PCIe nRST signal. Thus, to test the reboot behavior, I can put a small polyimide tape to block the nRST pin on the development board to avoid the reset. 

As usual, PCIe devices can be removed/reprogrammed/detected. However, please note that this is never the very correct way for debugging PCIe devices -- if it works, then your design works fine, but if it doesn't get detected, maybe a reboot/cold boot can make it work. Also found that the updated PCIe devices can't have a BAR size larger than the previous one, or errors like `BAR0 can't assign, no space` can occur. 

#### Raspberry Pi 5

This is being worked on. The RPi PCIe seems more demanding than ordinary PCs. 

#### Program flash

A cold boot test can be done with the bitstream (in .bin format) written to the SPI flash that the FPGA boots from. 

[Issue and reply from developers](https://github.com/wavelet-lab/usdr-fpga/issues/2)

With Vivado, the .bin can be generated when Settings -> Bitstream -> -bin_file is selected. 

With OpenXC7, a slightly patched [railnova/zynq-bit2bin](https://github.com/railnova/zynq-bit2bin) can be used to convert .bit to .bin. 

Then, with openFPGAloader, flash can be programmed with: `openFPGALoader -c ft232 -B ~/Downloads/spiOverJtag_xc7a35tcpg236.bit -f ./build/top.bin`. 

**PCIe Gen2 bitstreams generated by OpenXC7, converted by zynq-bit2bin without Vivado, written to flash with openFPGAloader, have been confirmed to cold boot successfully!** 
